#!/usr/bin/env python3
"""
„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê„ÉªROIÊúÄÈÅ©Âåñ„Ç∑„Çπ„ÉÜ„É†
È´òÂ∫¶„Å™È°ßÂÆ¢„Ç∏„É£„Éº„Éã„ÉºÂàÜÊûê„Å®„Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅ„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥
"""

import streamlit as st
import os
import sys
import json
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List, Any, Optional
import uuid
from scipy import stats
import networkx as nx

# „Éö„Éº„Ç∏Ë®≠ÂÆö
st.set_page_config(
    page_title="„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê",
    page_icon="üéØ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# „Ç´„Çπ„Çø„É†CSS
st.markdown("""
<style>
    /* „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâË®≠ÂÆö */
    .stApp {
        background-color: #0e1117;
    }
    
    /* „É°„Ç§„É≥„Éò„ÉÉ„ÉÄ„Éº */
    .attribution-header {
        background: linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%);
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        margin-bottom: 30px;
        color: white;
        position: relative;
        overflow: hidden;
    }
    
    .attribution-header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(ellipse at center, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: attributionPulse 6s ease-in-out infinite;
    }
    
    @keyframes attributionPulse {
        0%, 100% { transform: scale(0.9) rotate(0deg); opacity: 0.3; }
        50% { transform: scale(1.1) rotate(180deg); opacity: 0.7; }
    }
    
    .attribution-title {
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        position: relative;
        z-index: 1;
    }
    
    .attribution-subtitle {
        font-size: 1.2rem;
        opacity: 0.9;
        position: relative;
        z-index: 1;
    }
    
    /* „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„Ç´„Éº„Éâ */
    .attribution-card {
        background: linear-gradient(145deg, #1e293b 0%, #334155 100%);
        border: 2px solid rgba(139, 92, 246, 0.3);
        padding: 25px;
        border-radius: 20px;
        margin: 20px 0;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }
    
    .attribution-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
        transition: left 0.5s;
    }
    
    .attribution-card:hover::before {
        left: 100%;
    }
    
    .attribution-card:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 20px 40px rgba(139, 92, 246, 0.4);
        border-color: #8b5cf6;
    }
    
    /* „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà */
    .touchpoint {
        background: rgba(30, 41, 59, 0.8);
        padding: 15px;
        border-radius: 12px;
        margin: 10px 0;
        border-left: 4px solid #8b5cf6;
        transition: all 0.3s;
        position: relative;
        overflow: hidden;
    }
    
    .touchpoint:hover {
        background: rgba(30, 41, 59, 1);
        transform: translateX(5px);
        box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3);
    }
    
    .touchpoint-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .touchpoint-name {
        font-weight: bold;
        color: #8b5cf6;
        font-size: 1.1rem;
    }
    
    .touchpoint-contribution {
        background: rgba(139, 92, 246, 0.2);
        color: #8b5cf6;
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 0.8rem;
        font-weight: bold;
    }
    
    /* „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´ */
    .attribution-model {
        background: rgba(30, 41, 59, 0.6);
        padding: 20px;
        border-radius: 15px;
        border: 1px solid rgba(139, 92, 246, 0.3);
        margin: 15px 0;
        transition: all 0.3s;
    }
    
    .attribution-model:hover {
        border-color: rgba(139, 92, 246, 0.6);
        background: rgba(30, 41, 59, 0.8);
    }
    
    .model-active {
        border-color: #8b5cf6;
        background: rgba(139, 92, 246, 0.1);
        box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
    }
    
    .model-name {
        font-size: 1.2rem;
        font-weight: bold;
        color: #8b5cf6;
        margin-bottom: 10px;
    }
    
    .model-description {
        color: #94a3b8;
        margin-bottom: 15px;
    }
    
    .model-impact {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .impact-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #10b981;
    }
    
    /* „Ç´„Çπ„Çø„Éû„Éº„Ç∏„É£„Éº„Éã„Éº */
    .journey-step {
        background: rgba(30, 41, 59, 0.8);
        padding: 20px;
        border-radius: 15px;
        margin: 15px 0;
        border: 2px solid rgba(139, 92, 246, 0.3);
        position: relative;
        transition: all 0.3s;
    }
    
    .journey-step:hover {
        border-color: rgba(139, 92, 246, 0.6);
        transform: translateY(-3px);
    }
    
    .journey-step::before {
        content: '';
        position: absolute;
        left: -6px;
        top: 50%;
        transform: translateY(-50%);
        width: 12px;
        height: 12px;
        background: #8b5cf6;
        border-radius: 50%;
        box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3);
    }
    
    .step-number {
        background: #8b5cf6;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        font-size: 0.9rem;
    }
    
    .step-info {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .step-title {
        font-size: 1.1rem;
        font-weight: bold;
        color: #e2e8f0;
    }
    
    .step-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }
    
    .step-metric {
        background: rgba(139, 92, 246, 0.1);
        padding: 10px;
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(139, 92, 246, 0.2);
    }
    
    .metric-value {
        font-size: 1.3rem;
        font-weight: bold;
        color: #8b5cf6;
        margin-bottom: 3px;
    }
    
    .metric-label {
        color: #94a3b8;
        font-size: 0.8rem;
    }
    
    /* ROIÂàÜÊûê */
    .roi-metric {
        background: rgba(30, 41, 59, 0.8);
        padding: 25px;
        border-radius: 15px;
        text-align: center;
        border: 1px solid rgba(139, 92, 246, 0.3);
        transition: all 0.3s;
    }
    
    .roi-metric:hover {
        border-color: rgba(139, 92, 246, 0.6);
        transform: translateY(-5px);
    }
    
    .roi-value {
        font-size: 3rem;
        font-weight: bold;
        color: #8b5cf6;
        margin-bottom: 10px;
        text-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
    }
    
    .roi-label {
        color: #94a3b8;
        font-size: 1.1rem;
        margin-bottom: 10px;
    }
    
    .roi-change {
        font-size: 0.9rem;
        padding: 6px 12px;
        border-radius: 20px;
        display: inline-block;
    }
    
    .roi-positive {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
    }
    
    .roi-negative {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
    }
    
    /* Áµ±Ë®àÁöÑÊúâÊÑèÊÄß */
    .significance-test {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        border: 2px solid rgba(139, 92, 246, 0.3);
        padding: 25px;
        border-radius: 15px;
        margin: 20px 0;
    }
    
    .test-result {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 15px 0;
    }
    
    .test-metric {
        text-align: center;
    }
    
    .test-value {
        font-size: 1.8rem;
        font-weight: bold;
        color: #8b5cf6;
    }
    
    .test-label {
        color: #94a3b8;
        font-size: 0.9rem;
    }
    
    .significance-indicator {
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        text-align: center;
    }
    
    .significant {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        border: 1px solid rgba(16, 185, 129, 0.3);
    }
    
    .not-significant {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
    }
    
    /* „Éá„Éº„ÇøÂìÅË≥™„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
    .data-quality {
        background: rgba(30, 41, 59, 0.6);
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid #8b5cf6;
        margin: 15px 0;
    }
    
    .quality-score {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .quality-bar {
        flex-grow: 1;
        height: 8px;
        background: rgba(30, 41, 59, 0.8);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .quality-fill {
        height: 100%;
        background: linear-gradient(90deg, #8b5cf6 0%, #3b82f6 100%);
        border-radius: 4px;
        transition: width 1s ease;
    }
    
    /* ‰∫àÊ∏¨„É¢„Éá„É´ */
    .prediction-model {
        background: rgba(30, 41, 59, 0.6);
        padding: 20px;
        border-radius: 15px;
        border: 1px solid rgba(139, 92, 246, 0.3);
        margin: 20px 0;
    }
    
    .prediction-confidence {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 15px;
    }
    
    .confidence-circle {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: conic-gradient(#8b5cf6 0deg, #3b82f6 180deg, rgba(30, 41, 59, 0.5) 360deg);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
    }
    
    /* „Ç§„É≥„Çµ„Ç§„Éà„Ç´„Éº„Éâ */
    .insight-card {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        border: 1px solid rgba(139, 92, 246, 0.3);
        padding: 20px;
        border-radius: 15px;
        margin: 15px 0;
        transition: all 0.3s;
    }
    
    .insight-card:hover {
        border-color: rgba(139, 92, 246, 0.6);
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
    }
    
    .insight-icon {
        font-size: 2rem;
        margin-bottom: 10px;
    }
    
    .insight-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: #8b5cf6;
        margin-bottom: 10px;
    }
    
    /* „Éï„Ç°„Éç„É´ÊúÄÈÅ©Âåñ */
    .funnel-optimization {
        background: rgba(30, 41, 59, 0.6);
        padding: 20px;
        border-radius: 15px;
        border: 1px solid rgba(139, 92, 246, 0.3);
        margin: 20px 0;
    }
    
    .funnel-step {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 0;
        border-bottom: 1px solid rgba(139, 92, 246, 0.2);
    }
    
    .funnel-step:last-child {
        border-bottom: none;
    }
    
    .funnel-conversion {
        font-size: 1.2rem;
        font-weight: bold;
        color: #8b5cf6;
    }
    
    .funnel-improvement {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        padding: 4px 8px;
        border-radius: 10px;
        font-size: 0.8rem;
    }
</style>
""", unsafe_allow_html=True)

# „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖãÂàùÊúüÂåñ
if 'attribution_data' not in st.session_state:
    st.session_state.attribution_data = {}

if 'attribution_models' not in st.session_state:
    st.session_state.attribution_models = {}

if 'customer_journeys' not in st.session_state:
    st.session_state.customer_journeys = []

def generate_customer_journey_data():
    """È°ßÂÆ¢„Ç∏„É£„Éº„Éã„Éº„Éá„Éº„Çø„ÇíÁîüÊàê"""
    touchpoints = [
        {"name": "Google Search", "type": "Paid Search", "channel": "SEM"},
        {"name": "Facebook Ad", "type": "Social Media", "channel": "Social"},
        {"name": "Email Campaign", "type": "Email", "channel": "Email"},
        {"name": "Organic Search", "type": "Organic", "channel": "SEO"},
        {"name": "Display Ad", "type": "Display", "channel": "Display"},
        {"name": "YouTube Video", "type": "Video", "channel": "Video"},
        {"name": "LinkedIn Ad", "type": "Social Media", "channel": "Social"},
        {"name": "Direct Visit", "type": "Direct", "channel": "Direct"}
    ]
    
    journeys = []
    for i in range(50):  # 50„ÅÆÈ°ßÂÆ¢„Ç∏„É£„Éº„Éã„Éº„ÇíÁîüÊàê
        journey_length = np.random.randint(2, 6)
        journey_touchpoints = np.random.choice(touchpoints, journey_length, replace=False).tolist()
        
        # ÂêÑ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Å´ÊôÇÈñì„Å®„Ç≥„Çπ„Éà„ÇíËøΩÂä†
        for j, tp in enumerate(journey_touchpoints):
            tp['timestamp'] = datetime.now() - timedelta(days=np.random.randint(0, 30), hours=np.random.randint(0, 24))
            tp['cost'] = np.random.uniform(100, 2000)
            tp['position'] = j + 1
        
        journey = {
            'id': f"journey_{i+1}",
            'customer_id': f"customer_{i+1}",
            'touchpoints': journey_touchpoints,
            'conversion_value': np.random.uniform(5000, 50000),
            'conversion_date': datetime.now() - timedelta(days=np.random.randint(0, 7)),
            'converted': np.random.choice([True, False], p=[0.7, 0.3])
        }
        
        journeys.append(journey)
    
    return journeys

def calculate_attribution_models(journeys):
    """ÂêÑ„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´„ÅÆÁµêÊûú„ÇíË®àÁÆó"""
    models = {
        'First-Touch': {},
        'Last-Touch': {},
        'Linear': {},
        'Time-Decay': {},
        'U-Shaped': {},
        'W-Shaped': {},
        'Custom ML': {}
    }
    
    for journey in journeys:
        if not journey['converted']:
            continue
            
        touchpoints = journey['touchpoints']
        conversion_value = journey['conversion_value']
        
        if len(touchpoints) == 0:
            continue
        
        # First-Touch Attribution
        first_tp = touchpoints[0]['name']
        models['First-Touch'][first_tp] = models['First-Touch'].get(first_tp, 0) + conversion_value
        
        # Last-Touch Attribution
        last_tp = touchpoints[-1]['name']
        models['Last-Touch'][last_tp] = models['Last-Touch'].get(last_tp, 0) + conversion_value
        
        # Linear Attribution
        value_per_touchpoint = conversion_value / len(touchpoints)
        for tp in touchpoints:
            tp_name = tp['name']
            models['Linear'][tp_name] = models['Linear'].get(tp_name, 0) + value_per_touchpoint
        
        # Time-Decay Attribution
        total_weight = sum(2**i for i in range(len(touchpoints)))
        for i, tp in enumerate(touchpoints):
            weight = 2**i / total_weight
            tp_name = tp['name']
            models['Time-Decay'][tp_name] = models['Time-Decay'].get(tp_name, 0) + (conversion_value * weight)
        
        # U-Shaped Attribution (40% first, 40% last, 20% middle)
        if len(touchpoints) == 1:
            tp_name = touchpoints[0]['name']
            models['U-Shaped'][tp_name] = models['U-Shaped'].get(tp_name, 0) + conversion_value
        elif len(touchpoints) == 2:
            for tp in touchpoints:
                tp_name = tp['name']
                models['U-Shaped'][tp_name] = models['U-Shaped'].get(tp_name, 0) + (conversion_value * 0.5)
        else:
            # First touchpoint: 40%
            first_tp = touchpoints[0]['name']
            models['U-Shaped'][first_tp] = models['U-Shaped'].get(first_tp, 0) + (conversion_value * 0.4)
            
            # Last touchpoint: 40%
            last_tp = touchpoints[-1]['name']
            models['U-Shaped'][last_tp] = models['U-Shaped'].get(last_tp, 0) + (conversion_value * 0.4)
            
            # Middle touchpoints: 20% split
            middle_touchpoints = touchpoints[1:-1]
            if middle_touchpoints:
                value_per_middle = (conversion_value * 0.2) / len(middle_touchpoints)
                for tp in middle_touchpoints:
                    tp_name = tp['name']
                    models['U-Shaped'][tp_name] = models['U-Shaped'].get(tp_name, 0) + value_per_middle
        
        # Custom ML Model („Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥)
        ml_weights = np.random.dirichlet(np.ones(len(touchpoints)), size=1)[0]
        for i, tp in enumerate(touchpoints):
            tp_name = tp['name']
            models['Custom ML'][tp_name] = models['Custom ML'].get(tp_name, 0) + (conversion_value * ml_weights[i])
    
    return models

def calculate_roi_metrics(attribution_results, touchpoint_costs):
    """ROI„É°„Éà„É™„ÇØ„Çπ„ÇíË®àÁÆó"""
    roi_metrics = {}
    
    for model_name, attributions in attribution_results.items():
        model_roi = {}
        
        for touchpoint, attributed_value in attributions.items():
            cost = touchpoint_costs.get(touchpoint, 1000)  # „Éá„Éï„Ç©„É´„Éà„Ç≥„Çπ„Éà
            roi = (attributed_value - cost) / cost * 100 if cost > 0 else 0
            roas = attributed_value / cost if cost > 0 else 0
            
            model_roi[touchpoint] = {
                'attributed_value': attributed_value,
                'cost': cost,
                'roi': roi,
                'roas': roas
            }
        
        roi_metrics[model_name] = model_roi
    
    return roi_metrics

def perform_statistical_significance_test(model1_data, model2_data):
    """Áµ±Ë®àÁöÑÊúâÊÑèÊÄß„ÉÜ„Çπ„Éà„ÇíÂÆüË°å"""
    # „Çµ„É≥„Éó„É´„Éá„Éº„Çø„Åã„ÇâÁµ±Ë®àÂÄ§„ÇíË®àÁÆó
    values1 = list(model1_data.values())
    values2 = list(model2_data.values())
    
    if len(values1) < 2 or len(values2) < 2:
        return {
            'p_value': 1.0,
            'significant': False,
            'test_statistic': 0,
            'confidence_interval': (0, 0),
            'effect_size': 0
        }
    
    # T-test
    t_stat, p_value = stats.ttest_ind(values1, values2)
    
    # Effect size (Cohen's d)
    pooled_std = np.sqrt(((len(values1)-1)*np.var(values1) + (len(values2)-1)*np.var(values2)) / (len(values1)+len(values2)-2))
    effect_size = (np.mean(values1) - np.mean(values2)) / pooled_std if pooled_std > 0 else 0
    
    # Confidence interval
    se = pooled_std * np.sqrt(1/len(values1) + 1/len(values2))
    margin_error = stats.t.ppf(0.975, len(values1)+len(values2)-2) * se
    mean_diff = np.mean(values1) - np.mean(values2)
    ci = (mean_diff - margin_error, mean_diff + margin_error)
    
    return {
        'p_value': abs(p_value),
        'significant': abs(p_value) < 0.05,
        'test_statistic': abs(t_stat),
        'confidence_interval': ci,
        'effect_size': abs(effect_size)
    }

# „Éá„Éº„ÇøÁîüÊàê
customer_journeys = generate_customer_journey_data()
attribution_results = calculate_attribution_models(customer_journeys)

# „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Ç≥„Çπ„ÉàÔºà‰ªÆÊÉ≥„Éá„Éº„ÇøÔºâ
touchpoint_costs = {
    'Google Search': 5000,
    'Facebook Ad': 3000,
    'Email Campaign': 500,
    'Organic Search': 0,
    'Display Ad': 2000,
    'YouTube Video': 4000,
    'LinkedIn Ad': 3500,
    'Direct Visit': 0
}

roi_metrics = calculate_roi_metrics(attribution_results, touchpoint_costs)

# „Éò„ÉÉ„ÉÄ„Éº
st.markdown("""
<div class="attribution-header">
    <div class="attribution-title">üéØ „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê„ÉªROIÊúÄÈÅ©Âåñ</div>
    <div class="attribution-subtitle">È´òÂ∫¶„Å™È°ßÂÆ¢„Ç∏„É£„Éº„Éã„ÉºÂàÜÊûê„Å®„Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅ„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„Å´„Çà„ÇãÁ©∂Ê•µ„ÅÆROIÊúÄÈÅ©Âåñ</div>
</div>
""", unsafe_allow_html=True)

# ‰∏ªË¶Å„É°„Éà„É™„ÇØ„Çπ
col1, col2, col3, col4, col5 = st.columns(5)

total_conversions = sum(1 for j in customer_journeys if j['converted'])
total_revenue = sum(j['conversion_value'] for j in customer_journeys if j['converted'])
total_cost = sum(touchpoint_costs.values())
overall_roi = ((total_revenue - total_cost) / total_cost * 100) if total_cost > 0 else 0
avg_touchpoints = np.mean([len(j['touchpoints']) for j in customer_journeys])

with col1:
    st.markdown(f"""
    <div class="roi-metric">
        <div class="roi-value">{total_conversions}</div>
        <div class="roi-label">Á∑è„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥</div>
        <div class="roi-change roi-positive">+12.3%</div>
    </div>
    """, unsafe_allow_html=True)

with col2:
    st.markdown(f"""
    <div class="roi-metric">
        <div class="roi-value">¬•{total_revenue:,.0f}</div>
        <div class="roi-label">Á∑èÂèéÁõä</div>
        <div class="roi-change roi-positive">+18.7%</div>
    </div>
    """, unsafe_allow_html=True)

with col3:
    st.markdown(f"""
    <div class="roi-metric">
        <div class="roi-value">{overall_roi:.1f}%</div>
        <div class="roi-label">Á∑èÂêàROI</div>
        <div class="roi-change roi-positive">+23.5%</div>
    </div>
    """, unsafe_allow_html=True)

with col4:
    st.markdown(f"""
    <div class="roi-metric">
        <div class="roi-value">{avg_touchpoints:.1f}</div>
        <div class="roi-label">Âπ≥Âùá„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà</div>
        <div class="roi-change roi-positive">+0.3</div>
    </div>
    """, unsafe_allow_html=True)

with col5:
    overall_roas = total_revenue / total_cost if total_cost > 0 else 0
    st.markdown(f"""
    <div class="roi-metric">
        <div class="roi-value">{overall_roas:.1f}x</div>
        <div class="roi-label">Á∑èÂêàROAS</div>
        <div class="roi-change roi-positive">+0.8x</div>
    </div>
    """, unsafe_allow_html=True)

# „Çø„ÉñÊßãÊàê
tabs = st.tabs(["üìä „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´", "üõ§Ô∏è „Ç´„Çπ„Çø„Éû„Éº„Ç∏„É£„Éº„Éã„Éº", "üìà ROIÂàÜÊûê", "üî¨ Áµ±Ë®àÁöÑÊ§úÂÆö", "ü§ñ ‰∫àÊ∏¨ÂàÜÊûê"])

# „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´„Çø„Éñ
with tabs[0]:
    st.markdown("### üìä „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´ÊØîËºÉ")
    
    # „É¢„Éá„É´ÈÅ∏Êäû
    col1, col2 = st.columns(2)
    
    with col1:
        selected_model = st.selectbox(
            "„É°„Ç§„É≥„É¢„Éá„É´ÈÅ∏Êäû",
            list(attribution_results.keys()),
            index=0
        )
    
    with col2:
        comparison_model = st.selectbox(
            "ÊØîËºÉ„É¢„Éá„É´ÈÅ∏Êäû",
            list(attribution_results.keys()),
            index=1
        )
    
    # „É¢„Éá„É´ÁµêÊûúË°®Á§∫
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown(f"#### {selected_model} „É¢„Éá„É´ÁµêÊûú")
        
        model_data = attribution_results[selected_model]
        sorted_touchpoints = sorted(model_data.items(), key=lambda x: x[1], reverse=True)
        
        for touchpoint, value in sorted_touchpoints:
            percentage = (value / sum(model_data.values()) * 100) if sum(model_data.values()) > 0 else 0
            
            st.markdown(f"""
            <div class="touchpoint">
                <div class="touchpoint-header">
                    <span class="touchpoint-name">{touchpoint}</span>
                    <span class="touchpoint-contribution">{percentage:.1f}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>Ë≤¢ÁåÆ‰æ°ÂÄ§: ¬•{value:,.0f}</div>
                    <div>ROI: {roi_metrics[selected_model].get(touchpoint, {}).get('roi', 0):.1f}%</div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"#### {comparison_model} „É¢„Éá„É´ÁµêÊûú")
        
        comparison_data = attribution_results[comparison_model]
        sorted_comparison = sorted(comparison_data.items(), key=lambda x: x[1], reverse=True)
        
        for touchpoint, value in sorted_comparison:
            percentage = (value / sum(comparison_data.values()) * 100) if sum(comparison_data.values()) > 0 else 0
            
            st.markdown(f"""
            <div class="touchpoint">
                <div class="touchpoint-header">
                    <span class="touchpoint-name">{touchpoint}</span>
                    <span class="touchpoint-contribution">{percentage:.1f}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>Ë≤¢ÁåÆ‰æ°ÂÄ§: ¬•{value:,.0f}</div>
                    <div>ROI: {roi_metrics[comparison_model].get(touchpoint, {}).get('roi', 0):.1f}%</div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    # „É¢„Éá„É´ÊØîËºÉ„Ç∞„É©„Éï
    st.markdown("### üìà „É¢„Éá„É´Âà•Ë≤¢ÁåÆÂ∫¶ÊØîËºÉ")
    
    # „Éá„Éº„ÇøÊ∫ñÂÇô
    touchpoints = list(set(list(model_data.keys()) + list(comparison_data.keys())))
    model1_values = [model_data.get(tp, 0) for tp in touchpoints]
    model2_values = [comparison_data.get(tp, 0) for tp in touchpoints]
    
    fig_comparison = go.Figure()
    
    fig_comparison.add_trace(go.Bar(
        name=selected_model,
        x=touchpoints,
        y=model1_values,
        marker_color='rgba(139, 92, 246, 0.8)'
    ))
    
    fig_comparison.add_trace(go.Bar(
        name=comparison_model,
        x=touchpoints,
        y=model2_values,
        marker_color='rgba(59, 130, 246, 0.8)'
    ))
    
    fig_comparison.update_layout(
        title="„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´Âà•Ë≤¢ÁåÆÂ∫¶ÊØîËºÉ",
        xaxis_title="„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà",
        yaxis_title="Ë≤¢ÁåÆ‰æ°ÂÄ§ (¬•)",
        barmode='group',
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(color='white'),
        xaxis_tickangle=-45
    )
    
    st.plotly_chart(fig_comparison, use_container_width=True)
    
    # „É¢„Éá„É´Ë™¨Êòé
    st.markdown("### üìö „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥„É¢„Éá„É´Ë™¨Êòé")
    
    model_descriptions = {
        'First-Touch': {
            'description': 'ÊúÄÂàù„ÅÆ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Å´100%„ÅÆË≤¢ÁåÆ„ÇíÂâ≤„ÇäÂΩì„Å¶',
            'use_case': '„Éñ„É©„É≥„ÉâË™çÁü•„ÇÑ„Ç¢„Ç¶„Çß„Ç¢„Éç„ÇπÊñΩÁ≠ñ„ÅÆË©ï‰æ°„Å´ÈÅ©„Åó„Å¶„ÅÑ„Çã',
            'pros': 'Êñ∞Ë¶èÈ°ßÂÆ¢Áç≤Âæó„Å∏„ÅÆË≤¢ÁåÆ„ÅåÊòéÁ¢∫',
            'cons': '„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥„Å´Ëøë„ÅÑ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÇíÈÅéÂ∞èË©ï‰æ°'
        },
        'Last-Touch': {
            'description': 'ÊúÄÂæå„ÅÆ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Å´100%„ÅÆË≤¢ÁåÆ„ÇíÂâ≤„ÇäÂΩì„Å¶',
            'use_case': '„ÉÄ„Ç§„É¨„ÇØ„Éà„É¨„Çπ„Éù„É≥„ÇπÂ∫ÉÂëä„ÇÑ„ÇØ„É≠„Éº„Ç∏„É≥„Ç∞ÊñΩÁ≠ñ„ÅÆË©ï‰æ°',
            'pros': '„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥„Å´Áõ¥Áµê„Åô„ÇãË¶ÅÂõ†„ÅåÊòéÁ¢∫',
            'cons': '„Ç¢„Ç∑„Çπ„ÉàÂäπÊûú„ÅÆ„ÅÇ„Çã„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÇíÁÑ°Ë¶ñ'
        },
        'Linear': {
            'description': 'ÂÖ®„Å¶„ÅÆ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Å´ÂùáÁ≠â„Å´Ë≤¢ÁåÆ„ÇíÂàÜÈÖç',
            'use_case': 'ÂÖ®„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÅÆË≤¢ÁåÆ„ÇíÂÖ¨Âπ≥„Å´Ë©ï‰æ°„Åó„Åü„ÅÑÂ†¥Âêà',
            'pros': '„Åô„Åπ„Å¶„ÅÆ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÅåË©ï‰æ°„Åï„Çå„Çã',
            'cons': '„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÅÆÈáçË¶ÅÂ∫¶Â∑Æ„ÅåËÄÉÊÖÆ„Åï„Çå„Å™„ÅÑ'
        },
        'Time-Decay': {
            'description': '„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥„Å´Ëøë„ÅÑ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„Åª„Å©È´ò„ÅÑË≤¢ÁåÆÂ∫¶',
            'use_case': 'Áü≠ÊúüÈñì„ÅÆË≥ºË≤∑Ê§úË®é„Éó„É≠„Çª„Çπ„ÅÆÂàÜÊûê',
            'pros': 'ÊôÇÈñìÁöÑ„Å™ÂΩ±ÈüøÂ∫¶„ÇíËÄÉÊÖÆ',
            'cons': 'Èï∑ÊúüÁöÑ„Å™„Éñ„É©„É≥„Éá„Ç£„É≥„Ç∞ÂäπÊûú„ÇíÈÅéÂ∞èË©ï‰æ°'
        },
        'U-Shaped': {
            'description': 'ÊúÄÂàù„Å®ÊúÄÂæå„ÅÆ„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÇíÈáçË¶ñÔºàÂêÑ40%Ôºâ',
            'use_case': '„Ç¢„Ç¶„Çß„Ç¢„Éç„Çπ„Å®„ÇØ„É≠„Éº„Ç∏„É≥„Ç∞„ÅÆ‰∏°Êñπ„ÇíÈáçË¶ñ',
            'pros': 'Ë™çÁü•„Å®„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„Éê„É©„É≥„ÇπË©ï‰æ°',
            'cons': '‰∏≠Èñì„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà„ÅÆË©ï‰æ°„Åå‰Ωé„ÅÑ'
        },
        'Custom ML': {
            'description': 'Ê©üÊ¢∞Â≠¶Áøí„Å´„Çà„ÇãÂãïÁöÑ„Å™Ë≤¢ÁåÆÂ∫¶ÁÆóÂá∫',
            'use_case': 'Ë§áÈõë„Å™È°ßÂÆ¢„Ç∏„É£„Éº„Éã„Éº„ÅÆÈ´òÁ≤æÂ∫¶ÂàÜÊûê',
            'pros': '„Éá„Éº„Çø„Éâ„É™„Éñ„É≥„ÅßÊúÄÈÅ©Âåñ',
            'cons': '„Éñ„É©„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„ÇπÂåñ„ÄÅËß£Èáà„ÅåÂõ∞Èõ£'
        }
    }
    
    for model, info in model_descriptions.items():
        is_active = model in [selected_model, comparison_model]
        model_class = "attribution-model model-active" if is_active else "attribution-model"
        
        st.markdown(f"""
        <div class="{model_class}">
            <div class="model-name">{model}</div>
            <div class="model-description">{info['description']}</div>
            <div style="margin: 10px 0;">
                <strong>ÈÅ©Áî®Â†¥Èù¢:</strong> {info['use_case']}<br>
                <strong>„É°„É™„ÉÉ„Éà:</strong> {info['pros']}<br>
                <strong>„Éá„É°„É™„ÉÉ„Éà:</strong> {info['cons']}
            </div>
        </div>
        """, unsafe_allow_html=True)

# „Ç´„Çπ„Çø„Éû„Éº„Ç∏„É£„Éº„Éã„Éº„Çø„Éñ
with tabs[1]:
    st.markdown("### üõ§Ô∏è „Ç´„Çπ„Çø„Éû„Éº„Ç∏„É£„Éº„Éã„ÉºÂàÜÊûê")
    
    # „Ç∏„É£„Éº„Éã„ÉºÂàÜÊûêË®≠ÂÆö
    col1, col2, col3 = st.columns(3)
    
    with col1:
        journey_filter = st.selectbox(
            "„Éï„Ç£„É´„Çø„ÉºÊù°‰ª∂",
            ["ÂÖ®„Å¶", "„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Ê∏à„Åø", "Êú™„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥"]
        )
    
    with col2:
        min_touchpoints = st.slider("ÊúÄÂ∞è„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÊï∞", 1, 6, 2)
    
    with col3:
        max_touchpoints = st.slider("ÊúÄÂ§ß„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÊï∞", 2, 8, 6)
    
    # „Ç∏„É£„Éº„Éã„Éº„Éá„Éº„Çø„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    filtered_journeys = customer_journeys.copy()
    
    if journey_filter == "„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Ê∏à„Åø":
        filtered_journeys = [j for j in filtered_journeys if j['converted']]
    elif journey_filter == "Êú™„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥":
        filtered_journeys = [j for j in filtered_journeys if not j['converted']]
    
    filtered_journeys = [j for j in filtered_journeys if min_touchpoints <= len(j['touchpoints']) <= max_touchpoints]
    
    # „Ç∏„É£„Éº„Éã„Éº„Éë„Çø„Éº„É≥ÂàÜÊûê
    st.markdown("#### üìä „Ç∏„É£„Éº„Éã„Éº„Éë„Çø„Éº„É≥ÂàÜÊûê")
    
    # ÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å™„Ç∏„É£„Éº„Éã„Éº„Éë„Çπ
    journey_paths = {}
    for journey in filtered_journeys:
        path = " ‚Üí ".join([tp['name'] for tp in journey['touchpoints']])
        journey_paths[path] = journey_paths.get(path, 0) + 1
    
    top_paths = sorted(journey_paths.items(), key=lambda x: x[1], reverse=True)[:5]
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("##### üèÜ ÊúÄÈ†ªÂá∫„Ç∏„É£„Éº„Éã„Éº„Éë„Çπ")
        
        for i, (path, count) in enumerate(top_paths, 1):
            percentage = (count / len(filtered_journeys) * 100) if filtered_journeys else 0
            
            st.markdown(f"""
            <div class="journey-step">
                <div class="step-info">
                    <span class="step-number">{i}</span>
                    <span class="step-title">{path}</span>
                </div>
                <div style="margin-top: 10px;">
                    <strong>Âá∫ÁèæÂõûÊï∞:</strong> {count}Âõû ({percentage:.1f}%)
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    with col2:
        # „Ç∏„É£„Éº„Éã„ÉºÈï∑ÂàÜÂ∏É
        journey_lengths = [len(j['touchpoints']) for j in filtered_journeys]
        length_counts = pd.Series(journey_lengths).value_counts().sort_index()
        
        fig_length = px.bar(
            x=length_counts.index,
            y=length_counts.values,
            title="„Ç∏„É£„Éº„Éã„ÉºÈï∑ÂàÜÂ∏É",
            labels={'x': '„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÊï∞', 'y': '„Ç∏„É£„Éº„Éã„ÉºÊï∞'},
            color=length_counts.values,
            color_continuous_scale="Viridis"
        )
        
        fig_length.update_layout(
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color='white'),
            showlegend=False
        )
        
        st.plotly_chart(fig_length, use_container_width=True)
    
    # „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÈÅ∑ÁßªÂàÜÊûê
    st.markdown("#### üîÑ „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÈÅ∑ÁßªÂàÜÊûê")
    
    # ÈÅ∑Áßª„Éû„Éà„É™„ÉÉ„ÇØ„Çπ‰ΩúÊàê
    touchpoint_names = list(touchpoint_costs.keys())
    transition_matrix = np.zeros((len(touchpoint_names), len(touchpoint_names)))
    
    for journey in filtered_journeys:
        touchpoints = [tp['name'] for tp in journey['touchpoints']]
        for i in range(len(touchpoints) - 1):
            from_idx = touchpoint_names.index(touchpoints[i])
            to_idx = touchpoint_names.index(touchpoints[i + 1])
            transition_matrix[from_idx][to_idx] += 1
    
    # ÈÅ∑ÁßªÁ¢∫Áéá„Å´Â§âÊèõ
    row_sums = transition_matrix.sum(axis=1, keepdims=True)
    transition_probs = np.divide(transition_matrix, row_sums, out=np.zeros_like(transition_matrix), where=row_sums!=0)
    
    # „Éí„Éº„Éà„Éû„ÉÉ„Éó
    fig_transition = px.imshow(
        transition_probs,
        x=touchpoint_names,
        y=touchpoint_names,
        color_continuous_scale="Viridis",
        title="„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÈÅ∑ÁßªÁ¢∫Áéá„Éû„Éà„É™„ÉÉ„ÇØ„Çπ"
    )
    
    fig_transition.update_layout(
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(color='white')
    )
    
    st.plotly_chart(fig_transition, use_container_width=True)
    
    # ÂÄãÂà•„Ç∏„É£„Éº„Éã„ÉºË©≥Á¥∞Ë°®Á§∫
    st.markdown("#### üîç ÂÄãÂà•„Ç∏„É£„Éº„Éã„ÉºÂàÜÊûê")
    
    if filtered_journeys:
        selected_journey_idx = st.selectbox(
            "ÂàÜÊûê„Åô„Çã„Ç∏„É£„Éº„Éã„Éº„ÇíÈÅ∏Êäû",
            range(len(filtered_journeys)),
            format_func=lambda x: f"Journey {x+1} - {'Converted' if filtered_journeys[x]['converted'] else 'Not Converted'} - {len(filtered_journeys[x]['touchpoints'])} touchpoints"
        )
        
        selected_journey = filtered_journeys[selected_journey_idx]
        
        st.markdown(f"""
        <div class="insight-card">
            <div class="insight-title">„Ç∏„É£„Éº„Éã„ÉºË©≥Á¥∞</div>
            <div>
                <strong>È°ßÂÆ¢ID:</strong> {selected_journey['customer_id']}<br>
                <strong>„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥:</strong> {'Ê∏à„Åø' if selected_journey['converted'] else 'Êú™'}<br>
                <strong>„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥‰æ°ÂÄ§:</strong> ¬•{selected_journey['conversion_value']:,.0f}<br>
                <strong>„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÊï∞:</strong> {len(selected_journey['touchpoints'])}
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàË©≥Á¥∞
        for i, touchpoint in enumerate(selected_journey['touchpoints'], 1):
            time_since_start = (touchpoint['timestamp'] - selected_journey['touchpoints'][0]['timestamp']).days
            
            st.markdown(f"""
            <div class="journey-step">
                <div class="step-info">
                    <span class="step-number">{i}</span>
                    <span class="step-title">{touchpoint['name']} ({touchpoint['channel']})</span>
                </div>
                <div class="step-metrics">
                    <div class="step-metric">
                        <div class="metric-value">¬•{touchpoint['cost']:,.0f}</div>
                        <div class="metric-label">„Ç≥„Çπ„Éà</div>
                    </div>
                    <div class="step-metric">
                        <div class="metric-value">{time_since_start}</div>
                        <div class="metric-label">ÈñãÂßã„Åã„Çâ„ÅÆÊó•Êï∞</div>
                    </div>
                    <div class="step-metric">
                        <div class="metric-value">{touchpoint['timestamp'].strftime('%m/%d')}</div>
                        <div class="metric-label">Êé•Ëß¶Êó•</div>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)

# ROIÂàÜÊûê„Çø„Éñ
with tabs[2]:
    st.markdown("### üìà ROIÂàÜÊûê„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ")
    
    # ROI„É©„É≥„Ç≠„É≥„Ç∞
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üèÜ „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÂà•ROI„É©„É≥„Ç≠„É≥„Ç∞")
        
        # ÈÅ∏Êäû„Åï„Çå„Åü„É¢„Éá„É´„ÅÆROI„Éá„Éº„Çø
        model_roi = roi_metrics[selected_model]
        sorted_roi = sorted(model_roi.items(), key=lambda x: x[1]['roi'], reverse=True)
        
        for i, (touchpoint, metrics) in enumerate(sorted_roi, 1):
            roi_value = metrics['roi']
            roi_class = "roi-positive" if roi_value > 0 else "roi-negative"
            
            st.markdown(f"""
            <div class="touchpoint">
                <div class="touchpoint-header">
                    <span style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #8b5cf6; color: white; width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold;">{i}</span>
                        <span class="touchpoint-name">{touchpoint}</span>
                    </span>
                    <span class="touchpoint-contribution {roi_class}">{roi_value:+.1f}%</span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                    <div style="text-align: center;">
                        <div style="color: #8b5cf6; font-weight: bold;">¬•{metrics['attributed_value']:,.0f}</div>
                        <div style="color: #94a3b8; font-size: 0.8rem;">Ë≤¢ÁåÆ‰æ°ÂÄ§</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #ef4444; font-weight: bold;">¬•{metrics['cost']:,.0f}</div>
                        <div style="color: #94a3b8; font-size: 0.8rem;">„Ç≥„Çπ„Éà</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #10b981; font-weight: bold;">{metrics['roas']:.1f}x</div>
                        <div style="color: #94a3b8; font-size: 0.8rem;">ROAS</div>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("#### üìä ROI vs ROASÊï£Â∏ÉÂõ≥")
        
        # Êï£Â∏ÉÂõ≥„Éá„Éº„ÇøÊ∫ñÂÇô
        touchpoints_list = []
        roi_values = []
        roas_values = []
        costs = []
        attributed_values = []
        
        for touchpoint, metrics in model_roi.items():
            touchpoints_list.append(touchpoint)
            roi_values.append(metrics['roi'])
            roas_values.append(metrics['roas'])
            costs.append(metrics['cost'])
            attributed_values.append(metrics['attributed_value'])
        
        fig_scatter = px.scatter(
            x=roi_values,
            y=roas_values,
            size=costs,
            color=attributed_values,
            hover_name=touchpoints_list,
            labels={'x': 'ROI (%)', 'y': 'ROAS (x)', 'color': 'Ë≤¢ÁåÆ‰æ°ÂÄ§'},
            title="ROI vs ROAS Êï£Â∏ÉÂõ≥",
            color_continuous_scale="Viridis"
        )
        
        # Âü∫Ê∫ñÁ∑ö„ÇíËøΩÂä†
        fig_scatter.add_hline(y=1, line_dash="dash", line_color="rgba(255,255,255,0.5)")
        fig_scatter.add_vline(x=0, line_dash="dash", line_color="rgba(255,255,255,0.5)")
        
        fig_scatter.update_layout(
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color='white')
        )
        
        st.plotly_chart(fig_scatter, use_container_width=True)
    
    # ROIÊúÄÈÅ©ÂåñÊé®Â•®
    st.markdown("#### üí° ROIÊúÄÈÅ©ÂåñÊé®Â•®‰∫ãÈ†Ö")
    
    # ÊúÄÈÅ©ÂåñÊé®Â•®„ÇíÁîüÊàê
    optimization_recommendations = []
    
    for touchpoint, metrics in model_roi.items():
        roi = metrics['roi']
        roas = metrics['roas']
        cost = metrics['cost']
        
        if roi < 0:
            optimization_recommendations.append({
                'touchpoint': touchpoint,
                'type': 'urgent',
                'action': '‰∫àÁÆóÂâäÊ∏õ„Åæ„Åü„ÅØÂÅúÊ≠¢',
                'reason': f'ROI {roi:.1f}% „Å®ÊêçÂ§±Áä∂ÊÖã',
                'impact': f'ÊúàÈñì ¬•{abs(roi * cost / 100):,.0f} „ÅÆÊêçÂ§±ÂâäÊ∏õ'
            })
        elif roi < 50:
            optimization_recommendations.append({
                'touchpoint': touchpoint,
                'type': 'optimize',
                'action': '„Ç≠„É£„É≥„Éö„Éº„É≥ÊúÄÈÅ©Âåñ',
                'reason': f'ROI {roi:.1f}% „Å®‰Ωé„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ',
                'impact': f'ÊúÄÈÅ©Âåñ„Å´„Çà„Çä {roi * 1.5:.1f}% ROIÈÅîÊàêÂèØËÉΩ'
            })
        elif roi > 200:
            optimization_recommendations.append({
                'touchpoint': touchpoint,
                'type': 'scale',
                'action': '‰∫àÁÆóÂ¢óÈ°ç',
                'reason': f'ROI {roi:.1f}% „Å®È´ò„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ',
                'impact': f'‰∫àÁÆó2ÂÄç„ÅßÊúàÈñì ¬•{metrics["attributed_value"]:,.0f} „ÅÆËøΩÂä†ÂèéÁõäÊúüÂæÖ'
            })
    
    # Êé®Â•®‰∫ãÈ†Ö„ÇíË°®Á§∫
    for rec in optimization_recommendations:
        type_colors = {
            'urgent': '#ef4444',
            'optimize': '#f59e0b',
            'scale': '#10b981'
        }
        
        type_icons = {
            'urgent': 'üö®',
            'optimize': '‚ö°',
            'scale': 'üöÄ'
        }
        
        color = type_colors[rec['type']]
        icon = type_icons[rec['type']]
        
        st.markdown(f"""
        <div class="insight-card" style="border-left: 4px solid {color};">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="font-size: 1.5rem;">{icon}</span>
                <span class="insight-title">{rec['touchpoint']} - {rec['action']}</span>
            </div>
            <div style="margin-bottom: 10px;">
                <strong>ÁêÜÁî±:</strong> {rec['reason']}<br>
                <strong>ÊúüÂæÖÂäπÊûú:</strong> {rec['impact']}
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # „Éá„Éº„ÇøÂìÅË≥™„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº
    st.markdown("#### üìä „Éá„Éº„ÇøÂìÅË≥™„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº")
    
    # „Éá„Éº„ÇøÂìÅË≥™„Çπ„Ç≥„Ç¢Ë®àÁÆó
    data_completeness = 0.92  # „Çµ„É≥„Éó„É´„Éá„Éº„Çø„ÅÆÂÆåÂÖ®ÊÄß
    data_accuracy = 0.88      # „Éá„Éº„Çø„ÅÆÊ≠£Á¢∫ÊÄß
    sample_size_score = min(len(customer_journeys) / 1000, 1.0)  # „Çµ„É≥„Éó„É´„Çµ„Ç§„Ç∫„Çπ„Ç≥„Ç¢
    time_range_score = 0.95   # ÊôÇÈñìÁØÑÂõ≤„ÅÆÈÅ©ÂàáÊÄß
    
    overall_quality = (data_completeness + data_accuracy + sample_size_score + time_range_score) / 4
    
    quality_metrics = [
        ("„Éá„Éº„ÇøÂÆåÂÖ®ÊÄß", data_completeness, "Ê¨†Êêç„Éá„Éº„Çø„ÅÆÂ∞ë„Å™„Åï"),
        ("„Éá„Éº„ÇøÁ≤æÂ∫¶", data_accuracy, "„Éá„Éº„Çø„ÅÆÊ≠£Á¢∫ÊÄß„Å®‰∏ÄË≤´ÊÄß"),
        ("„Çµ„É≥„Éó„É´„Çµ„Ç§„Ç∫", sample_size_score, "Áµ±Ë®àÁöÑ‰ø°È†ºÊÄß„ÅÆ„Åü„ÇÅ„ÅÆ„Çµ„É≥„Éó„É´Êï∞"),
        ("ÊôÇÈñìÁØÑÂõ≤", time_range_score, "ÂàÜÊûê„Å´ÈÅ©„Åó„ÅüÊúüÈñì„ÅÆ„Éá„Éº„Çø")
    ]
    
    for metric_name, score, description in quality_metrics:
        st.markdown(f"""
        <div class="data-quality">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <strong>{metric_name}</strong>
                <span style="color: #8b5cf6; font-weight: bold;">{score*100:.0f}%</span>
            </div>
            <div class="quality-score">
                <div class="quality-bar">
                    <div class="quality-fill" style="width: {score*100}%;"></div>
                </div>
            </div>
            <div style="color: #94a3b8; font-size: 0.9rem; margin-top: 5px;">{description}</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Á∑èÂêàÂìÅË≥™„Çπ„Ç≥„Ç¢
    st.markdown(f"""
    <div class="significance-test">
        <div style="text-align: center;">
            <h4 style="color: #8b5cf6; margin-bottom: 15px;">Á∑èÂêà„Éá„Éº„ÇøÂìÅË≥™„Çπ„Ç≥„Ç¢</h4>
            <div style="font-size: 3rem; font-weight: bold; color: #8b5cf6; margin-bottom: 10px;">
                {overall_quality*100:.0f}%
            </div>
            <div style="color: #94a3b8;">
                „Åì„ÅÆ„Çπ„Ç≥„Ç¢„ÅØÂàÜÊûêÁµêÊûú„ÅÆ‰ø°È†ºÊÄß„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô
            </div>
        </div>
    </div>
    """, unsafe_allow_html=True)

# Áµ±Ë®àÁöÑÊ§úÂÆö„Çø„Éñ
with tabs[3]:
    st.markdown("### üî¨ Áµ±Ë®àÁöÑÊúâÊÑèÊÄßÊ§úÂÆö")
    
    # Ê§úÂÆöË®≠ÂÆö
    col1, col2 = st.columns(2)
    
    with col1:
        test_model1 = st.selectbox("Ê§úÂÆö„É¢„Éá„É´1", list(attribution_results.keys()), key="test_model1")
    
    with col2:
        test_model2 = st.selectbox("Ê§úÂÆö„É¢„Éá„É´2", list(attribution_results.keys()), index=1, key="test_model2")
    
    if test_model1 != test_model2:
        # Áµ±Ë®àÁöÑÊ§úÂÆöÂÆüË°å
        test_results = perform_statistical_significance_test(
            attribution_results[test_model1],
            attribution_results[test_model2]
        )
        
        # Ê§úÂÆöÁµêÊûúË°®Á§∫
        st.markdown(f"#### üìä {test_model1} vs {test_model2} Ê§úÂÆöÁµêÊûú")
        
        significance_class = "significant" if test_results['significant'] else "not-significant"
        significance_text = "Áµ±Ë®àÁöÑ„Å´ÊúâÊÑè" if test_results['significant'] else "Áµ±Ë®àÁöÑ„Å´ÈùûÊúâÊÑè"
        
        st.markdown(f"""
        <div class="significance-test">
            <div class="test-result">
                <div class="test-metric">
                    <div class="test-value">{test_results['p_value']:.4f}</div>
                    <div class="test-label">pÂÄ§</div>
                </div>
                <div class="test-metric">
                    <div class="test-value">{test_results['test_statistic']:.2f}</div>
                    <div class="test-label">Ê§úÂÆöÁµ±Ë®àÈáè</div>
                </div>
                <div class="test-metric">
                    <div class="test-value">{test_results['effect_size']:.2f}</div>
                    <div class="test-label">ÂäπÊûúÈáè</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <div class="significance-indicator {significance_class}">
                    {significance_text} (Œ± = 0.05)
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # ‰ø°È†ºÂå∫Èñì
        ci_lower, ci_upper = test_results['confidence_interval']
        
        st.markdown(f"""
        <div class="insight-card">
            <div class="insight-title">95% ‰ø°È†ºÂå∫Èñì</div>
            <div style="text-align: center; margin: 15px 0;">
                <span style="font-size: 1.5rem; font-weight: bold; color: #8b5cf6;">
                    [{ci_lower:,.0f}, {ci_upper:,.0f}]
                </span>
            </div>
            <div style="color: #94a3b8;">
                Áúü„ÅÆÂ∑Æ„Åå95%„ÅÆÁ¢∫Áéá„Åß„Åì„ÅÆÁØÑÂõ≤ÂÜÖ„Å´Â≠òÂú®„Åó„Åæ„Åô
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Ê§úÂÆöËß£Èáà
        interpretation = []
        
        if test_results['significant']:
            interpretation.append("‚úÖ 2„Å§„ÅÆ„É¢„Éá„É´Èñì„Å´„ÅØÁµ±Ë®àÁöÑ„Å´ÊúâÊÑè„Å™Â∑Æ„Åå„ÅÇ„Çä„Åæ„Åô")
            if test_results['effect_size'] > 0.8:
                interpretation.append("üî• ÂäπÊûúÈáè„ÅåÂ§ß„Åç„Åè„ÄÅÂÆüÁî®ÁöÑ„Å´ÊÑèÂë≥„ÅÆ„ÅÇ„ÇãÂ∑Æ„Åß„Åô")
            elif test_results['effect_size'] > 0.5:
                interpretation.append("‚ö° ÂäπÊûúÈáè„ÅØ‰∏≠Á®ãÂ∫¶„Åß„ÄÅÊ≥®ÁõÆ„Åô„Åπ„ÅçÂ∑Æ„Åß„Åô")
            else:
                interpretation.append("üìä ÂäπÊûúÈáè„ÅØÂ∞è„Åï„ÅÑ„Åß„Åô„Åå„ÄÅÁµ±Ë®àÁöÑ„Å´„ÅØÊúâÊÑè„Åß„Åô")
        else:
            interpretation.append("‚ùå 2„Å§„ÅÆ„É¢„Éá„É´Èñì„Å´Áµ±Ë®àÁöÑÊúâÊÑèÂ∑Æ„ÅØË™ç„ÇÅ„Çâ„Çå„Åæ„Åõ„Çì")
            interpretation.append("ü§î „Çà„ÇäÂ§ö„Åè„ÅÆ„Éá„Éº„Çø„ÅåÂøÖË¶Å„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì")
        
        if test_results['p_value'] < 0.001:
            interpretation.append("‚≠ê ÈùûÂ∏∏„Å´Âº∑„ÅÑË®ºÊã†„ÅßÂ∑Æ„Åå„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô")
        elif test_results['p_value'] < 0.01:
            interpretation.append("üí™ Âº∑„ÅÑË®ºÊã†„ÅßÂ∑Æ„Åå„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô")
        
        st.markdown("#### üí° Ê§úÂÆöÁµêÊûú„ÅÆËß£Èáà")
        
        for i, interp in enumerate(interpretation, 1):
            st.markdown(f"""
            <div class="insight-card">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="background: #8b5cf6; color: white; width: 25px; height: 25px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold;">{i}</span>
                    <span>{interp}</span>
                </div>
            </div>
            """, unsafe_allow_html=True)
        
        # „Éë„ÉØ„ÉºÂàÜÊûê
        st.markdown("#### ‚ö° „Éë„ÉØ„ÉºÂàÜÊûê")
        
        # „Çµ„É≥„Éó„É´„Çµ„Ç§„Ç∫„ÅÆÂΩ±Èüø„Çí„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
        sample_sizes = [50, 100, 200, 500, 1000]
        power_values = []
        
        for n in sample_sizes:
            # Á∞°Êòì„Éë„ÉØ„ÉºË®àÁÆóÔºàÂÆüÈöõ„ÅØ„Çà„ÇäË§áÈõëÔºâ
            z_alpha = 1.96  # Œ± = 0.05„ÅÆËá®ÁïåÂÄ§
            effect_size = test_results['effect_size']
            power = 1 - stats.norm.cdf(z_alpha - effect_size * np.sqrt(n/2))
            power_values.append(max(0, min(1, power)))
        
        fig_power = px.line(
            x=sample_sizes,
            y=power_values,
            title="„Çµ„É≥„Éó„É´„Çµ„Ç§„Ç∫„Å®Ê§úÂÆöÂäõ„ÅÆÈñ¢‰øÇ",
            labels={'x': '„Çµ„É≥„Éó„É´„Çµ„Ç§„Ç∫', 'y': 'Ê§úÂÆöÂäõ'},
            markers=True
        )
        
        fig_power.add_hline(y=0.8, line_dash="dash", line_color="rgba(255,255,255,0.5)", 
                           annotation_text="Êé®Â•®Ê§úÂÆöÂäõ 0.8")
        
        fig_power.update_layout(
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color='white')
        )
        
        st.plotly_chart(fig_power, use_container_width=True)
    
    # Â§öÈáçÊØîËºÉË£úÊ≠£
    st.markdown("#### üî¢ Â§öÈáçÊØîËºÉË£úÊ≠£")
    
    st.markdown("""
    <div class="insight-card">
        <div class="insight-title">BonferroniË£úÊ≠£</div>
        <div style="margin: 15px 0;">
            Ë§áÊï∞„ÅÆ„É¢„Éá„É´„ÇíÂêåÊôÇ„Å´ÊØîËºÉ„Åô„ÇãÂ†¥Âêà„ÄÅÁ¨¨‰∏ÄÁ®Æ„ÅÆÈÅéË™§Áéá„ÇíÂà∂Âæ°„Åô„Çã„Åü„ÇÅ„ÄÅ
            ÊúâÊÑèÊ∞¥Ê∫ñ„ÇíÊØîËºÉÂõûÊï∞„ÅßÂâ≤„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
        </div>
        <div style="text-align: center;">
            <span style="font-size: 1.2rem; color: #8b5cf6;">
                Ë£úÊ≠£Ê∏à„Åø Œ± = 0.05 / {len(attribution_results)} = {0.05/len(attribution_results):.4f}
            </span>
        </div>
    </div>
    """, unsafe_allow_html=True)

# ‰∫àÊ∏¨ÂàÜÊûê„Çø„Éñ  
with tabs[4]:
    st.markdown("### ü§ñ ‰∫àÊ∏¨ÂàÜÊûê„ÉªÊ©üÊ¢∞Â≠¶Áøí„É¢„Éá„É´")
    
    # ‰∫àÊ∏¨„É¢„Éá„É´Ë®≠ÂÆö
    col1, col2 = st.columns(2)
    
    with col1:
        prediction_target = st.selectbox(
            "‰∫àÊ∏¨ÂØæË±°",
            ["„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Á¢∫Áéá", "LTV‰∫àÊ∏¨", "ÊúÄÈÅ©‰∫àÁÆóÈÖçÂàÜ", "„ÉÅ„É£„Éº„É≥‰∫àÊ∏¨"]
        )
    
    with col2:
        prediction_horizon = st.selectbox(
            "‰∫àÊ∏¨ÊúüÈñì",
            ["1ÈÄ±Èñì", "1„É∂Êúà", "3„É∂Êúà", "6„É∂Êúà"]
        )
    
    # ‰∫àÊ∏¨„É¢„Éá„É´ÁµêÊûúÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
    st.markdown("#### üéØ ‰∫àÊ∏¨„É¢„Éá„É´ÁµêÊûú")
    
    if prediction_target == "„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Á¢∫Áéá":
        # „Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Á¢∫Áéá‰∫àÊ∏¨
        touchpoint_conversion_probs = {}
        for tp in touchpoint_costs.keys():
            base_prob = np.random.uniform(0.02, 0.15)
            touchpoint_conversion_probs[tp] = base_prob
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### üìä „Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÂà•„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Á¢∫Áéá")
            
            sorted_probs = sorted(touchpoint_conversion_probs.items(), key=lambda x: x[1], reverse=True)
            
            for i, (touchpoint, prob) in enumerate(sorted_probs, 1):
                confidence = np.random.uniform(0.75, 0.95)
                
                st.markdown(f"""
                <div class="prediction-model">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h5 style="color: #8b5cf6; margin-bottom: 5px;">{touchpoint}</h5>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #10b981;">
                                {prob*100:.1f}%
                            </div>
                        </div>
                        <div class="prediction-confidence">
                            <div class="confidence-circle">
                                {confidence*100:.0f}%
                            </div>
                            <div style="color: #94a3b8; font-size: 0.8rem;">‰ø°È†ºÂ∫¶</div>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
        
        with col2:
            # ‰∫àÊ∏¨Á≤æÂ∫¶„Ç∞„É©„Éï
            days = list(range(1, 31))
            actual = np.random.uniform(0.03, 0.12, 30)
            predicted = actual + np.random.normal(0, 0.01, 30)
            
            fig_accuracy = go.Figure()
            
            fig_accuracy.add_trace(go.Scatter(
                x=days,
                y=actual,
                mode='lines+markers',
                name='ÂÆüÈöõ„ÅÆ„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Áéá',
                line=dict(color='#10b981', width=2)
            ))
            
            fig_accuracy.add_trace(go.Scatter(
                x=days,
                y=predicted,
                mode='lines+markers',
                name='‰∫àÊ∏¨„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Áéá',
                line=dict(color='#8b5cf6', width=2, dash='dash')
            ))
            
            fig_accuracy.update_layout(
                title="‰∫àÊ∏¨Á≤æÂ∫¶Ê§úË®º",
                xaxis_title="Êó•Êï∞",
                yaxis_title="„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Áéá",
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font=dict(color='white')
            )
            
            st.plotly_chart(fig_accuracy, use_container_width=True)
    
    elif prediction_target == "ÊúÄÈÅ©‰∫àÁÆóÈÖçÂàÜ":
        # ÊúÄÈÅ©‰∫àÁÆóÈÖçÂàÜ
        st.markdown("##### üí∞ AIÊé®Â•®‰∫àÁÆóÈÖçÂàÜ")
        
        total_budget = 100000  # ‰ªÆÊÉ≥Á∑è‰∫àÁÆó
        
        # ÁèæÂú®„ÅÆÈÖçÂàÜ
        current_allocation = {tp: cost for tp, cost in touchpoint_costs.items() if cost > 0}
        current_total = sum(current_allocation.values())
        current_percentages = {tp: (cost/current_total)*100 for tp, cost in current_allocation.items()}
        
        # AIÊé®Â•®ÈÖçÂàÜÔºàROI„Éô„Éº„ÇπÔºâ
        roi_scores = {tp: roi_metrics[selected_model].get(tp, {}).get('roi', 0) for tp in current_allocation.keys()}
        positive_roi_tps = {tp: max(0, roi) for tp, roi in roi_scores.items()}
        total_roi_score = sum(positive_roi_tps.values())
        
        if total_roi_score > 0:
            ai_allocation = {tp: (score/total_roi_score)*total_budget for tp, score in positive_roi_tps.items()}
        else:
            ai_allocation = current_allocation
        
        ai_percentages = {tp: (alloc/total_budget)*100 for tp, alloc in ai_allocation.items()}
        
        # ÊØîËºÉË°®Á§∫
        allocation_comparison = []
        for tp in current_allocation.keys():
            current_pct = current_percentages.get(tp, 0)
            ai_pct = ai_percentages.get(tp, 0)
            change = ai_pct - current_pct
            
            allocation_comparison.append({
                'touchpoint': tp,
                'current': current_pct,
                'ai_recommended': ai_pct,
                'change': change
            })
        
        allocation_df = pd.DataFrame(allocation_comparison)
        
        fig_allocation = go.Figure()
        
        fig_allocation.add_trace(go.Bar(
            name='ÁèæÂú®„ÅÆÈÖçÂàÜ',
            x=allocation_df['touchpoint'],
            y=allocation_df['current'],
            marker_color='rgba(239, 68, 68, 0.8)'
        ))
        
        fig_allocation.add_trace(go.Bar(
            name='AIÊé®Â•®ÈÖçÂàÜ',
            x=allocation_df['touchpoint'],
            y=allocation_df['ai_recommended'],
            marker_color='rgba(139, 92, 246, 0.8)'
        ))
        
        fig_allocation.update_layout(
            title="‰∫àÁÆóÈÖçÂàÜÊØîËºÉ",
            xaxis_title="„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„Éà",
            yaxis_title="‰∫àÁÆóÈÖçÂàÜ (%)",
            barmode='group',
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(color='white'),
            xaxis_tickangle=-45
        )
        
        st.plotly_chart(fig_allocation, use_container_width=True)
        
        # ÈÖçÂàÜÂ§âÊõ¥„Ç§„É≥„Éë„ÇØ„Éà
        st.markdown("##### üìà ÈÖçÂàÜÂ§âÊõ¥„Å´„Çà„ÇãÊúüÂæÖ„Ç§„É≥„Éë„ÇØ„Éà")
        
        total_current_roi = sum(roi_metrics[selected_model].get(tp, {}).get('roi', 0) * current_percentages.get(tp, 0)/100 for tp in current_allocation.keys())
        total_ai_roi = sum(roi_metrics[selected_model].get(tp, {}).get('roi', 0) * ai_percentages.get(tp, 0)/100 for tp in current_allocation.keys())
        
        roi_improvement = total_ai_roi - total_current_roi
        
        st.markdown(f"""
        <div class="significance-test">
            <div style="text-align: center;">
                <h4 style="color: #8b5cf6; margin-bottom: 15px;">‰∫àÊÉ≥ROIÊîπÂñÑ</h4>
                <div style="font-size: 3rem; font-weight: bold; color: #10b981; margin-bottom: 10px;">
                    +{roi_improvement:.1f}%
                </div>
                <div style="color: #94a3b8;">
                    AIÊé®Â•®ÈÖçÂàÜ„Å´„Çà„ÇäÊúüÂæÖ„Åï„Çå„ÇãËøΩÂä†ÂèéÁõäÁéá
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # „É¢„Éá„É´ÊÄßËÉΩÊåáÊ®ô
    st.markdown("#### üìä „É¢„Éá„É´ÊÄßËÉΩÊåáÊ®ô")
    
    performance_metrics = [
        {"metric": "Á≤æÂ∫¶ (Accuracy)", "value": 0.847, "benchmark": 0.800},
        {"metric": "ÈÅ©ÂêàÁéá (Precision)", "value": 0.823, "benchmark": 0.750},
        {"metric": "ÂÜçÁèæÁéá (Recall)", "value": 0.789, "benchmark": 0.700},
        {"metric": "F1„Çπ„Ç≥„Ç¢", "value": 0.806, "benchmark": 0.725},
        {"metric": "AUC-ROC", "value": 0.912, "benchmark": 0.850}
    ]
    
    col1, col2 = st.columns(2)
    
    with col1:
        for metric in performance_metrics[:3]:
            performance_class = "roi-positive" if metric['value'] > metric['benchmark'] else "roi-negative"
            
            st.markdown(f"""
            <div class="roi-metric">
                <div class="roi-value">{metric['value']:.3f}</div>
                <div class="roi-label">{metric['metric']}</div>
                <div class="roi-change {performance_class}">
                    „Éô„É≥„ÉÅ„Éû„Éº„ÇØ: {metric['benchmark']:.3f}
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    with col2:
        for metric in performance_metrics[3:]:
            performance_class = "roi-positive" if metric['value'] > metric['benchmark'] else "roi-negative"
            
            st.markdown(f"""
            <div class="roi-metric">
                <div class="roi-value">{metric['value']:.3f}</div>
                <div class="roi-label">{metric['metric']}</div>
                <div class="roi-change {performance_class}">
                    „Éô„É≥„ÉÅ„Éû„Éº„ÇØ: {metric['benchmark']:.3f}
                </div>
            </div>
            """, unsafe_allow_html=True)
    
    # ÁâπÂæ¥ÈáèÈáçË¶ÅÂ∫¶
    st.markdown("#### üéØ ÁâπÂæ¥ÈáèÈáçË¶ÅÂ∫¶")
    
    feature_importance = {
        "„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÈ†ÜÂ∫è": 0.234,
        "„ÉÅ„É£„Éç„É´ÁµÑ„ÅøÂêà„Çè„Åõ": 0.198,
        "Êé•Ëß¶ÈñìÈöî": 0.167,
        "„Éá„Éê„Ç§„Çπ„Çø„Ç§„Éó": 0.143,
        "ÊôÇÈñìÂ∏Ø": 0.089,
        "Â≠£ÁØÄË¶ÅÂõ†": 0.076,
        "Â∫ÉÂëäË≤ªÁî®": 0.058,
        "Á´∂ÂêàÊ¥ªÂãï": 0.035
    }
    
    fig_importance = px.bar(
        x=list(feature_importance.values()),
        y=list(feature_importance.keys()),
        orientation='h',
        title="„É¢„Éá„É´ÁâπÂæ¥ÈáèÈáçË¶ÅÂ∫¶",
        color=list(feature_importance.values()),
        color_continuous_scale="Viridis"
    )
    
    fig_importance.update_layout(
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(color='white'),
        xaxis_title="ÈáçË¶ÅÂ∫¶",
        yaxis_title="ÁâπÂæ¥Èáè"
    )
    
    st.plotly_chart(fig_importance, use_container_width=True)

# „Çµ„Ç§„Éâ„Éê„Éº
with st.sidebar:
    st.header("üéØ „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê")
    
    # ÂàÜÊûêË®≠ÂÆö
    st.subheader("‚öôÔ∏è ÂàÜÊûêË®≠ÂÆö")
    
    analysis_period = st.selectbox(
        "ÂàÜÊûêÊúüÈñì",
        ["ÈÅéÂéª7Êó•", "ÈÅéÂéª30Êó•", "ÈÅéÂéª90Êó•", "„Ç´„Çπ„Çø„É†"]
    )
    
    attribution_window = st.slider(
        "„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥Á™ì (Êó•)",
        1, 30, 14
    )
    
    confidence_level = st.selectbox(
        "‰ø°È†ºÊ∞¥Ê∫ñ",
        ["90%", "95%", "99%"],
        index=1
    )
    
    st.markdown("---")
    
    # „Éá„Éº„ÇøÊ¶ÇË¶Å
    st.subheader("üìä „Éá„Éº„ÇøÊ¶ÇË¶Å")
    
    st.metric("Á∑è„Ç∏„É£„Éº„Éã„ÉºÊï∞", len(customer_journeys))
    st.metric("„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Êï∞", total_conversions)
    st.metric("Âπ≥Âùá„Çø„ÉÉ„ÉÅ„Éù„Ç§„É≥„ÉàÊï∞", f"{avg_touchpoints:.1f}")
    
    conversion_rate = (total_conversions / len(customer_journeys) * 100) if customer_journeys else 0
    st.metric("„Ç≥„É≥„Éê„Éº„Ç∏„Éß„É≥Áéá", f"{conversion_rate:.1f}%")
    
    st.markdown("---")
    
    # „É¢„Éá„É´ÊØîËºÉ
    st.subheader("üîç „É¢„Éá„É´ÊØîËºÉ")
    
    model_total_values = {}
    for model, attributions in attribution_results.items():
        model_total_values[model] = sum(attributions.values())
    
    sorted_models = sorted(model_total_values.items(), key=lambda x: x[1], reverse=True)
    
    for i, (model, total_value) in enumerate(sorted_models, 1):
        medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i}‰Ωç"
        st.markdown(f"{medal} {model}")
        st.caption(f"¬•{total_value:,.0f}")
    
    st.markdown("---")
    
    # „Ç¢„É©„Éº„Éà
    st.subheader("üö® „Ç¢„É©„Éº„Éà")
    
    alerts = [
        {"type": "warning", "message": "Display Ad„ÅÆÂäπÁéá‰Ωé‰∏ã", "time": "10ÂàÜÂâç"},
        {"type": "info", "message": "Organic SearchË≤¢ÁåÆÂ∫¶‰∏äÊòá", "time": "1ÊôÇÈñìÂâç"},
        {"type": "success", "message": "„É¢„Éá„É´Á≤æÂ∫¶Âêë‰∏ä", "time": "3ÊôÇÈñìÂâç"}
    ]
    
    for alert in alerts:
        alert_icon = {"warning": "‚ö†Ô∏è", "info": "‚ÑπÔ∏è", "success": "‚úÖ"}[alert['type']]
        st.markdown(f"{alert_icon} {alert['message']}")
        st.caption(alert['time'])
    
    st.markdown("---")
    
    # „Ç®„ÇØ„Çπ„Éù„Éº„Éà
    st.subheader("üì• „Ç®„ÇØ„Çπ„Éù„Éº„Éà")
    
    if st.button("üìä „É¨„Éù„Éº„ÉàÁîüÊàê", use_container_width=True):
        st.success("üìà „Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê„É¨„Éù„Éº„Éà„ÇíÁîüÊàê‰∏≠...")
    
    if st.button("üíæ „Éá„Éº„Çø„Ç®„ÇØ„Çπ„Éù„Éº„Éà", use_container_width=True):
        export_data = {
            "attribution_results": attribution_results,
            "roi_metrics": roi_metrics,
            "customer_journeys": len(customer_journeys),
            "export_timestamp": datetime.now().isoformat()
        }
        
        st.download_button(
            "üì• JSON„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ",
            data=json.dumps(export_data, ensure_ascii=False, indent=2),
            file_name=f"attribution_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json"
        )
    
    st.markdown("---")
    
    # „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥
    st.subheader("üß≠ „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥")
    
    if st.button("üè† „Éõ„Éº„É†„Å´Êàª„Çã", use_container_width=True):
        st.switch_page("pages/../home.py")
    
    if st.button("üåê „Éû„É´„ÉÅ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†", use_container_width=True):
        st.switch_page("pages/multi_platform_manager.py")
    
    if st.button("‚ö° „É™„Ç¢„É´„Çø„Ç§„É†ÊúÄÈÅ©Âåñ", use_container_width=True):
        st.switch_page("pages/realtime_ad_optimizer.py")

# „Éï„ÉÉ„Çø„Éº
st.markdown("---")
st.caption("üéØ Attribution Analysis: ÊúÄÂÖàÁ´Ø„ÅÆ„Éû„É´„ÉÅ„Çø„ÉÉ„ÉÅ„Ç¢„Éà„É™„Éì„É•„Éº„Ç∑„Éß„É≥ÂàÜÊûê„Åß„ÄÅÁúü„ÅÆROI„ÇíËß£Êòé„Åó„ÄÅ„Éû„Éº„Ç±„ÉÜ„Ç£„É≥„Ç∞ÊäïË≥á„ÇíÊúÄÈÅ©Âåñ„Åó„Åæ„Åô„ÄÇ")